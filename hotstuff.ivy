#lang ivy1.7

#TODO: Model certificates

module total_order(r) = {
    axiom r(X,X)                        # Reflexivity
    axiom r(X, Y) & r(Y, Z) -> r(X, Z)  # Transitivity
    axiom r(X, Y) & r(Y, X) -> X = Y    # Anti-symmetry
    axiom r(X, Y) | r(Y, X)             # Totality
}

type node
type quorum
type block
type height

individual genesis:block
individual min:height
relation le(X:height, Y:height)
instantiate total_order(le)

#min is the minimum height
axiom forall H. le(min,H)

relation is_good(N:node) # should be used only in the proof!

relation member(N:node, Q:quorum)
axiom forall Q1,Q2. exists N. is_good(N) & member(N, Q1) & member(N, Q2)

#assign to every block its block height
function block_height(B:block):height
#assign to every block a predecessor
relation prev(B:block, C:block)
relation proposed(B:block)
#this shows that node N signed block B at height H
relation voted(N:node,B:block)
#assign for every node its lock
function lock(N:node):block
relation certified(B:block)

relation just(B:block, C:block)

relation ancestor(B:block, C:block)

definition certified(B) = B=genesis | exists Q. forall N. member(N,Q) -> voted(N,B)

#init
after init {
    prev(B,C) := false;
    prev(genesis,genesis) := true;
    proposed(B) := false;
    proposed(genesis) := true;
    block_height(B) := min;
    ancestor(B,C) := B = C;
    voted(N,B) := false;
    lock(N) := genesis;
    just(B,C) := false;
    just(genesis,genesis) := true;
}

action propose(b_new:block,b_prev:block,h:height) = {
    require ~proposed(b_new);
    require proposed(b_prev);
    require le(block_height(b_prev),h);
    require block_height(b_prev) ~=h;
    var j:block;
    require just(j,b_prev);

    #create tree
    prev(b_new,b_prev):= true;
    block_height(b_new) := h;
    ancestor(B,b_new) := ancestor(B,b_prev) | B=b_prev;

    #mark as proposed and set just
    proposed(b_new) := true;
    if certified(b_prev) {
        just(b_new,b_prev) := true;
    } else {
        just(b_new,j) := true;
    }
}

action vote(n:node, h:height, b:block) = {
    require proposed(b);
    #RULE 1 good nodes will only vote for b if they have not yet voted at larger height
    require is_good(n) & voted(n,B) -> le(block_height(B), block_height(b))
                                        & block_height(B) ~= block_height(b);

    var j:block;
    var jj:block;
    require just(j,b) & just(jj,j);
    #RULE 2
    require is_good(n) -> ancestor(lock(n),b) | (le(block_height(lock(n)), block_height(j))
                                                & block_height(lock(n)) ~= block_height(j));

    voted(n,b) := true;

    if le(block_height(lock(n)), block_height(jj)) & block_height(jj) ~= block_height(lock(n)) {
        lock(n) := jj;
    }
}


export propose
export vote

private {
    #from tree
    #invariant prev(B,C) & prev(B,D) -> C=D
    #invariant prev(B,C) & prev(C,B) -> C=genesis
    invariant prev(genesis,genesis)
    invariant ~proposed(B) -> ~prev(B,C)
    #invariant proposed(B) & prev(B,C) -> proposed(C)
    #invariant proposed(B) -> ancestor(genesis,B)
    #invariant prev(B,C) -> ancestor(C,B)
    #invariant ancestor(B,C) & ~proposed(B) -> B=C
    #invariant ancestor(B,C) & ancestor(C,B) -> B=C
    #invariant ancestor(B,C) & ancestor(C,D) -> ancestor(B,D)
    
    
    invariant voted(N,B) -> proposed(B)
    #invariant voted(N,B) ->  B=genesis | block_height(B)~=min
    #invariant voted(N,B) & voted(N,C) & is_good(N) & B~=C -> block_height(B) ~= block_height(C)
    invariant just(B,C) -> certified(C)
}

invariant ~(B ~= C & certified(B) & certified(C) & block_height(B) = block_height(C))


relation confirm(B:block,C:block,D:block)
definition confirm(B,C,D) = prev(C,B) & just(C,B) & prev(D,C) & just(D,C) & certified(D)

invariant confirm(B,C,D) & certified(E) & le(block_height(B),block_height(E)) -> ancestor(B,E)
