#lang ivy1.7

#TODO: Model certificates

module total_order(r) = {
    axiom r(X,X)                        # Reflexivity
    axiom r(X, Y) & r(Y, Z) -> r(X, Z)  # Transitivity
    axiom r(X, Y) & r(Y, X) -> X = Y    # Anti-symmetry
    axiom r(X, Y) | r(Y, X)             # Totality
}

type block
type height

individual genesis:block
individual min:height
relation le(X:height, Y:height)
instantiate total_order(le)

#min is the minimum height
axiom forall H. le(min,H)

#assign to every block its block height
function block_height(B:block):height
#assign to every block a predecessor
relation prev(B:block,C:block)
relation proposed(B:block)

relation ancestor(B:block, C:block)

#init
after init {
    prev(B,C) := false;
    prev(genesis,genesis) := true;
    proposed(B) := false;
    proposed(genesis) := true;
    block_height(B) := min;
    ancestor(B,C) := B=C;
}

action propose(b_new:block,b_prev:block,h:height) = {
    require ~proposed(b_new);
    require proposed(b_prev);
    require le(block_height(b_prev),h);
    require block_height(b_prev) ~=h;

    #create tree
    prev(b_new,b_prev):= true;
    block_height(b_new) := h;

    #mark as proposed and set just
    proposed(b_new) := true;

    ancestor(B,b_new) := ancestor(B,b_prev) | B=b_prev;
}


export propose

private {
    invariant prev(B,C) & prev(B,D) -> C=D
    invariant prev(B,C) & prev(C,B) -> C=genesis
    invariant prev(genesis,genesis)
    invariant ~proposed(B) -> ~prev(B,C)
    invariant proposed(B) & prev(B,C) -> proposed(C)
    invariant proposed(B) -> ancestor(genesis,B)
    #invariant proposed(B) -> exists D. prev(B,D)
    #invariant prev(B,C) -> exists D. prev(B,D)
    invariant prev(B,C) -> ancestor(C,B)
    invariant ancestor(B,C) & ~proposed(B) -> B=C
    invariant ancestor(B,C) & ancestor(C,B) -> B=C
    invariant ancestor(B,C) & ancestor(C,D) -> ancestor(B,D)
    #invariant ancestor(B,C) & B~=C -> exists D. prev(C,D) & ancestor(B,D)
}

